/* Generated by re2c 3.1 on Mon Dec 18 01:55:41 2023 */

#pragma once
#include <string>
#include <queue>
enum Result {
    SUCCESS,
    FAILURE
};

enum Token_t {
    BOOL_T,
    TRUE_V,
    FALSE_V,
    INT_T,
    INT_V,
    STRING_T,
    STRING_V,
    CMD_T,
    CMD_V,
    
    ASSIGN_OP,
    ADD_OP,
    SUB_OP,
    MULT_OP,
    MOD_OP,
    NEG_OP,

    AND_OP,
    OR_OP,
    XOR_OP,

    EQ_CMP,
    NEQ_CMP,
    LT_CMP,
    GT_CMP,

    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_BRACE,
    CLOSE_BRACE,
    OPEN_PAREN,
    CLOSE_PAREN,

    IF_KW,
    ELSE_KW,
    WHILE_KW,
    FOR_KW,
    BREAK_KW,
    CONTINUE_KW,

    END_STATEMENT,
    VARNAME,
    IGNORE
};

typedef struct Token {
    Token_t type;
    std::string value;
    Token(){};
    Token(Token_t t): type(t) {};
    Token(Token_t t, std::string v): type(t), value(v) {};
};

class Lexer {
    private:
        const char* m_cursor;
        const char* m_marker;
        const char* m_limit;
        Token m_token;
        std::queue<Token>* m_q;
        Result next_token();
    public:
        void tokenize(std::string s);
        void print_tokens();
        Lexer(std::queue<Token>* q): m_q(q){};
};
